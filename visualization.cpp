#include <core/cvstd.hpp>
#include <core/mat.hpp>
#include <core/mat.inl.hpp>
#include <core/types.hpp>
#include <imgcodecs.hpp>
#include <imgproc.hpp>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <map>
#include <string>
#include <vector>
#include <boost/numeric/ublas/io.hpp>

#include "constantsImgPro.hpp"

//function to create a vector containing all the names of the files described by ...
std::vector<std::string> CreateFilenameList(const char *tpl, unsigned int start, unsigned int stop)
{
    char buffer[64];
    std::vector<std::string> ret;

    for (unsigned int i = start; i < stop; ++i)
    {
        snprintf(buffer, 64, tpl, i);
        ret.push_back(std::string(buffer));
    }

    return ret;
}

// function to read the indices of the bacteria, corresponding to the output of the tracking (indices are generated by a python file)
void read_ids(std::string filename, std::map<real,std::vector<real>>& ids, int& highest_id){
    std::ifstream in;
    real id;
    highest_id=0;
    in.open(filename);
    assert(!in.fail() && "Could not open file");
    std::string line, firstline;
    int t=1;
    std::getline(in, firstline); // skip first line (because it's a header)
    while(std::getline(in,line)){
        std::stringstream linestream(line);
        while (!linestream.eof()){
            linestream >> id;
            if (id>highest_id){
            	highest_id=id;
            }
            ids[t].push_back(id);
        }
        t++;
    }

}
void read_cov(std::string filename, std::map<int, std::map<int, boost::numeric::ublas::matrix<real>>>& cov, int& highest_id){
	highest_id=0;
	int t, id;
    boost::numeric::ublas::matrix<real> p_diag(4,1);

    std::ifstream in;
    in.open(filename);
    assert(!in.fail() && "Could not open file");
    std::string line;
    while(std::getline(in,line)){
        std::stringstream linestream(line);
        linestream >> t;
        linestream >> id;
        if(id>highest_id){
        	highest_id=id;
        }
        linestream >>p_diag(0,0);
        linestream >>p_diag(1,0);
        linestream >>p_diag(2,0);
        linestream >>p_diag(3,0);

        cov[t][id]=p_diag;
    }
}


bool string2bool(std::string var){
    if(var == "true" || var == "TRUE" || var=="1" ){
  	    return true;
    }
    else if(var == "false" || var == "FALSE" || var=="0" ){
        return false;
    }
    return false; // TODO: how to deal with that ?
}


void readParameters(std::string conf_file, int& X, int& Y, int& DX, int& DY, bool & plot_cov, int& time_start, int& time_stop, int& time_step, std::string& data_directory, std::string& filenametpl, bool& print_index, int& input_kind){
    std::ifstream infile(conf_file);
    std::string line;
    int count_param_positions=0;
    while(std::getline(infile,line)){
    	line=line.substr(0, line.find("//"));
    	if(!line.empty()){
    		switch(count_param_positions){
    		    case 0: X=atoi(line.c_str());
    		            break;
    		    case 1: Y=atoi (line.c_str());
    		            break;
    		    case 2: DX=atoi (line.c_str());
    		        	break;
    		    case 3: DY=atoi (line.c_str());
    		            break;
    		    case 4: plot_cov=string2bool(line.c_str());
    		            break;
    		    case 5: time_start=atoi(line.c_str());
    		        		            break;
    		    case 6: time_stop=atoi(line.c_str());
    		        		            break;
    		    case 7: time_step=atoi(line.c_str());
    		        		            break;
                //TODO: deal with fact that there can be a some spaces at the end
    		    case 8: data_directory=line.c_str();
    		        		            break;
    		    case 9: filenametpl=line.c_str();
    		        		            break;
    		    case 26: print_index=string2bool(line.c_str());
    		             break;
    		    case 30: input_kind=atoi(line.c_str());
    		    	     break;

    		}
            count_param_positions++;
    	}
    }
}


int main(void)
{

    // visualization of the results
    std::string filenametpl;
    cv::Mat original;
    cv::Point bac, text_pos, time_pos; // contains coordinate x and y of the point, coordinate of where we write the index, and coordinate of where we print the time
	time_pos=cv::Point(15,25);
    cv::Scalar col;   //color of the point (blue, yellow, red)
    std::string output_name; // name of an output file
    int time_start, time_stop, time_step;
    std::string dir="";
    std::string data_directory;
    int input_kind;
    bool print_index, plot_cov;
    int X, Y, DX, DY;

    readParameters("20160719_1/config.txt", X, Y, DX, DY, plot_cov, time_start, time_stop, time_step, data_directory, filenametpl, print_index, input_kind);


    std::vector<std::string> filenames = CreateFilenameList(filenametpl.c_str(), time_start-1, time_stop);

    // get identity information from data_exp_tracked_ids.txt (was generated by a python code)
    int highest_id;
    std::map<real,std::vector<real>> ids;
    if(input_kind==1){
        read_ids(dir+data_directory+"data_exp_tracked_ids.txt", ids, highest_id);
    }

	std::map<int, std::map<int, boost::numeric::ublas::matrix<real>>> cov;
    if(input_kind==2){
    	read_cov(dir+data_directory+"updated_error_covariance.txt", cov, highest_id);
    	//highest_id=500;
    }

    // assign a different random blue, yellow and red amount to each bacteria identity, keep it in vectors
	srand(1); //seed for random choice of the color
	std::vector<int> bleu, jaune, rouge;
	for (int i=0; i<highest_id; i++){
		bleu.push_back(rand()%200);
	}
	for (int i=0; i<highest_id; i++){
		jaune.push_back(rand()%200);
	}
	for (int i=0; i<highest_id; i++){
		rouge.push_back(rand()%200);
	}

	real x, y, x_cov, y_cov;
    cv::Size axes;
    double angle=0, startAngle=0, endAngle=359;
    cv::Rect subrect = cv::Rect(X, Y, DX, DY);

    int id;

    if(input_kind==1){

    	// find highest index
        int counter, i=1;
	    std::ifstream in;
	    in.open(dir+data_directory+"data_exp_tracked.txt");
	    assert(!in.fail() && "Could not open file");
	    std::string line;
	    while(std::getline(in,line)){
	    	if((i+2)%4==0){
	    		counter=0;
    			original= cv::imread(dir+data_directory+filenames[(i+2)/4]);
    			// keep only the part we worked on
    			cv::Mat subImage(original, subrect);
    			original=subImage;
	            std::stringstream linestream(line);
	            while (!linestream.eof()){
                    linestream >> x;
                    linestream >> y;
                    y=DY-y;
                    id=ids[((i+2)/4)][counter];
                    counter++;
        	    	col[0]=bleu[id];
        	    	col[1]=jaune[id];
        	    	col[2]=rouge[id];
        	    	bac=cv::Point(x, y);
        	        cv::circle(original, bac, 2, col, -1);
        	        // plot indices
        	        if(print_index){
        	            text_pos=cv::Point(x+5, y+5);
        	            cv::putText(original, std::to_string(id), text_pos, CV_FONT_HERSHEY_DUPLEX, 0.3, cv::Scalar(255,0,0));
        	        }
	            }
	    		cv::putText(original, "t= "+std::to_string((i+2)/4), time_pos, CV_FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0,0,0));
	    	    output_name=dir+data_directory +"pred_"+filenames[(i+2)/4-1];
	    	    cv::imwrite(output_name, original);
	    	}

            i++;
	    }

    }

    if(input_kind==2){
    	int t=time_start;
    	int t_next=time_start+1;
    	std::ifstream in;
        in.open(dir+data_directory+"updated_states.txt");
    	assert(!in.fail() && "Could not open file");
    	std::string line;
  		original= cv::imread(dir+data_directory+filenames[t-1]);
   		// keep only the part we worked on
       	cv::Mat subImage(original, subrect);
	        original=subImage;
    	while(std::getline(in,line)){
    		std::stringstream linestream(line);
    		linestream >> t;
    		if(t==t_next){
    			// close the last one
         	    cv::putText(original, "t= "+std::to_string(t-1), time_pos, CV_FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0,0,0));
	     	    output_name=dir +data_directory+"pred_"+filenames[t-2];
	 	        cv::imwrite(output_name, original);
	 	        // open the new one
          		original= cv::imread(dir+data_directory+filenames[t-1]);
           		// keep only the part we work on
   	        	cv::Mat subImage(original, subrect);
   		        original=subImage;
   		        t_next++;
    		}

            linestream >> id;
            linestream >>x;
            linestream >>y;
            y=DY-y;
            col[0]=bleu[id];
            col[1]=jaune[id];
            col[2]=rouge[id];
            bac=cv::Point(x, y);
            if(!plot_cov){
                cv::circle(original, bac, 2, col, -1);
            }
	        if(print_index){
	            text_pos=cv::Point(x+5, y+5);
	            cv::putText(original, std::to_string(id), text_pos, CV_FONT_HERSHEY_DUPLEX, 0.3, cv::Scalar(255,0,0));
	        }
	        if (plot_cov){
	            x_cov=cov[t][id](0,0);
	            y_cov=cov[t][id](1,0);
                axes=cv::Size(x_cov, y_cov);
	            cv::ellipse(original, bac, axes, angle, startAngle, endAngle, col);
	        }
    	}

    }


std::cout<<"Done!"<<std::endl;

}
