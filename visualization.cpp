/**
 * @file   kalman.cpp
 * @author Louisiane Lemaire
 * @date   2016-08
 *
 * @brief  This code enable to visualize the result of kalman.cpp (input_kind=1) or the result of tracking.cpp (input_kind=1) (https://github.com/SwarmingSoft/ImageProcessing), that is to say the tracking of bacteria trajectories over multiple frames.
 *
 *
 * The updated positions estimate are plotted onto the original pictures, with a different color and index for each bacteria, or an ellipse
 * showing the covariance in x and y around the updated position estimate.
 *
 * The input files are:
 * -updated_states: contains for each time step the index and updated states estimate (x, y, vx, vy) of each bacteria
 * -updated_error_covariance: contains for each time step the index and the diagonal of the covariance matrix of each bacteria
 * -the original pictures
 *
 * This code can also plot the result of the tracking performed by tracking.cpp, https://github.com/SwarmingSoft/ImageProcessing (when input_kind=1)
 * in order to compare with the result of the tracking performed with the Kalman filter
 * In this case the input files are:
 * -data_exp_tracked.txt: contains positions and angles of tracked bacteria for each time step
 * -data_exp_tracked_ids.txt (generated by ids_generate.py, https://github.com/SwarmingSoft/ImageProcessing) : contains corresponding indices
 * -the original pictures
 *
 * Output files:
 * -updated positions estimate plotted on the original image (pred_ORIGINAL_NAME)
 */


#include <boost/numeric/ublas/matrix.hpp>
#include <core/cvstd.hpp>
#include <core/mat.hpp>
#include <core/mat.inl.hpp>
#include <core/types.hpp>
#include <imgcodecs.hpp>
#include <imgproc/imgproc_c.h>
#include <imgproc.hpp>
#include <cassert>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "kalman_functions.hpp"

using namespace std;
using namespace cv;

// function to read the indices of the bacteria corresponding to the output of the tracking with tracking.cpp (https://github.com/SwarmingSoft/ImageProcessing)
// (the indices are generated by a python code, and are contained in data_exp_tracked_ids.txt)
void read_ids(string filename, map<double, vector<double>>& ids, int& highest_id) {
	ifstream in;
	double id;
	highest_id = 0;
	in.open(filename);
	assert(!in.fail() && "Could not open file");
	string line, firstline;
	int t = 1; // TODO
	getline(in, firstline); // skip first line (because it's a header)
	while (getline(in, line)) {
		stringstream linestream(line);
		while (!linestream.eof()) {
			linestream >> id;
			if (id > highest_id) {
				highest_id = id;
			}
			ids[t].push_back(id);
		}
		t++;
	}

}

// read the covariance values (diagonal of the error covariance matrix p of the kalman filter), from updated_error_covariance.txt (output of kalman.cpp)
// put them in a map of map, with as key the time step and the index of the bacteria, and as value a 4 by 1 matrix containing the variance in x, y, dx, dy
void read_cov(string filename, map<int, map<int, boost::numeric::ublas::matrix<double>>>& cov, int& highest_id) {
	highest_id=0;
	int t, id;
	boost::numeric::ublas::matrix<double> p_diag(4,1);

	ifstream in;
	in.open(filename);
	assert(!in.fail() && "Could not open file");
	string line;
	while(getline(in,line)) {
		stringstream linestream(line);
		linestream >> t;
		linestream >> id;
		if(id>highest_id) {
			highest_id=id;
		}
		linestream >>p_diag(0,0);
		linestream >>p_diag(1,0);
		linestream >>p_diag(2,0);
		linestream >>p_diag(3,0);

		cov[t][id]=p_diag;
	}
}

int main(int argc, char **argv) {

	// check that the correct number of parameters (just one, the directory where the configuration file is) is given
	if (argc != 2) {
		cerr << "Wrong number of parameters. Usage: " << endl << "\t" << argv[0] << " CONFIG_FILE_DIRECTORY" << endl;
		return -1;
	}

	// read arguments from the configuration file config.txt
	configuration_parameters_t params;
	params = read_parameters(string(argv[1]) + "/config.txt");

	// names of the original pictures, we will plot on them the updated position estimates
	vector<string> filenames = create_filename_list(params.pictures_filename_tpl.c_str(), params.time_start, params.time_stop);


	int highest_id; // highest index over all bacteria and all time_step

	/* input type 1: plot data from kalman.cpp */
	// read the covariance values (diagonal of the error covariance matrix p of the kalman filter), from updated_error_covariance.txt (output of kalman.cpp)
	// put them in a map of map, with as key the time step and the index of the bacteria, and as value a 4 by 1 matrix containing the variance in x, y, dx, dy
	// also get the highest index
	map<int, map<int, boost::numeric::ublas::matrix<double>>>cov;
	if (params.input_kind == 1) {
		read_cov(params.working_dir + params.data_dir + "updated_error_covariance.txt", cov, highest_id);
	}

    /* input type 2: plot data from tracking.cpp and ids_generate.py */
	// get identity information from data_exp_tracked_ids.txt (was generated by a python code)
	// also get the highest index
	map<double, vector<double>> ids;
	if (params.input_kind == 2) {
		read_ids(params.working_dir + params.data_dir + "data_exp_tracked_ids.txt", ids, highest_id);
	}


    // we want to plot positions with a different color for each bacteria index, constant over time
	// assign a different random blue, green and red amount to each bacteria index, keep it in vectors
	srand(1); // seed for random choice of the color
	vector<int> blue, green, red;
	for (int i = 0; i < highest_id; i++) {
		blue.push_back(rand() % 200);
		green.push_back(rand() % 200);
		red.push_back(rand() % 200);
	}


	Mat original; // store one original picture
	Rect subrect = Rect(params.subregion_x, params.subregion_y, params.dx, params.dy); // subregion of the pictures we are considering

	double x, y, x_cov, y_cov; // x and y coordinates, values of x and y updated estimate error covariance

	Point time_pos; // contains coordinate x and y of the point, coordinate of where we write the index, and coordinate of where we print the time
	time_pos = Point(15, 25);

	Size axes; // contains x_cov and y_cov values, needed in the function to plot ellipses
	double angle = 0, startAngle = 0, endAngle = 359; // parameters for plotting of a covariance ellipse

	int id; // store one index
	Scalar col;   // store the color of one point (blue, green, red)

	string output_name; // name of an output file (a picture with updated estimate positions plotted on it)


	/* input type 1: plot data from kalman.cpp */
	if (params.input_kind == 1) {
		int t = params.time_start; // first time step
		int t_next = params.time_start + params.time_step; // second time step
		ifstream in;
		in.open(params.working_dir + params.data_dir + "updated_states.txt"); // file containing updated position estimate values
		assert(!in.fail() && "Could not open file");
		string line; // one line contains the information for one bacteria (time step, id, x, y, vx, vy)
		original = imread(params.working_dir + params.data_dir + filenames[t - params.time_start]); // first original picture
		original = Mat(original, subrect); // keep only a subregion of it
		putText(original, "t= " + to_string(t), time_pos, CV_FONT_HERSHEY_DUPLEX, 0.7, Scalar(0, 0, 255)); // write the time step on it
		while (getline(in, line)) {
			stringstream linestream(line);
			linestream >> t; // time step
			if (t == t_next) { // when the time step we read is different from the last ones
				// output the last picture
				output_name = params.working_dir + params.data_dir + "pred_" + filenames[t - params.time_step - params.time_start];
				imwrite(output_name, original);
				// open the next picture
				original = imread(params.working_dir + params.data_dir + filenames[t - params.time_start]);
				original = Mat(original, subrect); // keep only a subregion of it
				putText(original, "t= " + to_string(t), time_pos, CV_FONT_HERSHEY_DUPLEX, 0.7, Scalar(0, 0, 255)); // write the time step on it
   		        t_next+=params.time_step; // increment the next time step
			}

			linestream >> id;   // index
			linestream >> x;    // x and y coordinates
			linestream >> y;
			y = params.dy - y;  // the y axe is upside down in the data from updated_states.txt compared to the way opencv plot points
			col[0] = blue[id];  // color of this index
			col[1] = green[id];
			col[2] = red[id];
			Point bac = Point(x, y);  // contains x and y coordinate, used by the function that plots a point
			if (!params.plot_cov) {
				circle(original, bac, 2, col, -1); // plot a point at this position
			}
			if (params.print_index) {
				// plot the index next to it
				Point text_pos = Point(x + 5, y + 5);
				putText(original, to_string(id), text_pos, CV_FONT_HERSHEY_DUPLEX, 0.4, Scalar(255, 0, 0));
			}
			if (params.plot_cov) {
				x_cov = cov[t][id](0, 0);
				y_cov = cov[t][id](1, 0);
				axes = Size(x_cov, y_cov);
				ellipse(original, bac, axes, angle, startAngle, endAngle, col); // plot covariance ellipse
			}
		}

	}


    /* input type 2: plot data from tracking.cpp and ids_generate.py */
	if (params.input_kind == 2) {
		int counter, i = 1;
		ifstream in;
		in.open(params.working_dir + params.data_dir + "data_exp_tracked.txt"); // file containing tracked positions
		assert(!in.fail() && "Could not open file");
		string line;
		while (getline(in, line)) {
			if ((i + 2) % 4 == 0) {
				counter = 0;
				original = imread(params.working_dir + params.data_dir + filenames[(i + 2) / 4]); // open one original picture
				original = Mat(original, subrect); // keep only a subregion of it
				stringstream linestream(line);
				while (!linestream.eof()) {
					linestream >> x;  // read x and y coordinates
					linestream >> y;
					y = params.dy - y;  // the y axe is upside down in the data from updated_states.txt compared to the way open cv plot points
					id = ids[((i + 2) / 4)][counter]; // index
					counter++;
					col[0] = blue[id]; // color of this index
					col[1] = green[id];
					col[2] = red[id];
					Point bac = Point(x, y); // contains x and y coordinate, used by the function that plots a point
					circle(original, bac, 2, col, -1); // plot a point at this position
					if (params.print_index) {
						// plot the index next to it
						Point text_pos = Point(x + 5, y + 5);
						putText(original, to_string(id), text_pos, CV_FONT_HERSHEY_DUPLEX, 0.3, Scalar(255, 0, 0));
					}
				}
				putText(original, "t= " + to_string((i + 2) / 4), time_pos, CV_FONT_HERSHEY_DUPLEX, 0.5, Scalar(150, 200, 0)); // plot time step
				output_name = params.working_dir + params.data_dir + "pred_" + filenames[(i + 2) / 4 - 1]; // name of the output picture file
				imwrite(output_name, original);
			}
			i++;
		}
	}

	cout << "Done!" << endl;

}
